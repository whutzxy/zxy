%%  intialization  设定初值

% fid = fopen('output_zhangh1_atn_1.bin');
fid = fopen('no_leg_atn_1.bin'); %读入图像数据
x = fread(fid,inf,'float');
x=reshape(x,[512,512,100]);
fclose(fid);
xtrue=x(:,:,65)*600;
clim=[63 113];
% figure,imshow(xtrue',clim);
% title('true')
view=180;%25 40 58 80 116  旋转一周采样角个数
view1=180;
% 设定投影几何参数sg
sg = sino_geom('fan','nb', 672, 'na',view, 'ds', 1.40, ...
    'dsd', 1040, 'dso',570 ,'dfs',0, ...
    'strip_width','d','source_offset',0,'channel_offset',0,'orbit',360, 'down', 1);%0.909976
sg1 = sino_geom('fan','nb', 672, 'na',view1, 'ds', 1.40, ...
    'dsd', 1040, 'dso',570 ,'dfs',0, ...
    'strip_width','d','source_offset',0,'channel_offset',0,'orbit',360, 'down', 1);
% fan (扇束) nb(探测器个数) na(旋转一周采样角个数) ds(偏转距离) dsd(源到探测器的距离) orbit(旋转角度) down(降采样比例) 
% 设定图像几何参数ig
ig = image_geom('nx',512, 'ny', 512,'dx',1.17, 'offset_x',0,'down', 1);
% nx, ny(重建图像大小) dx(像素大小)
ig.mask = conv2(double6(xtrue > 0), ones(3), 'same') > 0;%二维卷积
% 生成系统矩阵G
G = Gtomo2_strip(sg,ig);% windows下可运行，数据量不能过大 % fessler
G1 = Gtomo2_strip(sg1,ig);
sino=G*xtrue;
sino1=G1*xtrue;
% figure,imagesc(sino);
%% low_dose and sparse-view simulation  低剂量和稀疏视图模拟

kappa=5e3;%设定一个归一化参数 
sino_new = sino/kappa;%归一化   表示归一化后的投影数据
sino_new1 = sino1/kappa;
max(sino_new(:))%调整kappa,保证最大值在6-7之间
max(sino_new1(:))
bi=1e6;%设定入射光子数,光子数越小，剂量越低
ri = 0.1; %偏移量，可设置为0
yb = bi.*exp(-sino_new) + ri; % 指数变换，得到raw data 
yb1 = bi.*exp(-sino_new1) + ri;
yi = poisson(yb) + 10*randn(size(yb)); %仿真噪声，泊松分布量子噪声+正态分布电子噪声
yi1 = poisson(yb1) + 10*randn(size(yb1));
li_hat = -log((yi-ri)./bi); % 对数变换 
li_hat1 = -log((yi1-ri)./bi);
li_hat(yi-ri <= 0) = 0; % 非负
li_hat(yi1-ri <= 0) = 0; 
sino_noise = kappa*li_hat; % 去归一化
sino_noise1 = kappa*li_hat1;

tmp = fbp2(sg, ig);
tmp1 = fbp2(sg1, ig);
xfbp_noise = fbp2(sino_noise, tmp);% fbp方法重建做初值 
xfbp_noise1 = fbp2(sino_noise1, tmp1);
%figure,imshow(xfbp_noise',clim);

Im_noise=double(xfbp_noise1);%转换精度
iter=200;
dt=1; % constant step size 恒定步长
 %beta=0;% 惩罚因子
 beta=4;
Im_pwls_tv=pwls_piccs(Im_noise,0,sino_noise,0, G,beta,dt,iter);



function J=pwls_piccs(I,P,y,alpha,G,beta,dt,iter) 

if ~exist('alpha')
   alpha=0;% CS based on TV without prior image
end
if ~exist('iter')
   iter=10;
end


a=10.^(-8);% a  - data small enough
[ny,nx]=size(I); 

param.nx = 512;
param.ny = 512;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% 初始化DL参数 %%%%%%%%%%%%%%%%%%%%
% DLMRI iterations
    num=1;  % DL算法的迭代次数
    n=6*6; % Patch的尺寸。字典D的行数。Patch size, i.e., Total # of pixels in square patch (e.g., n=36, n=64)
    r=1; % Overlap Stride (e.g., r=1); 每个patch之间的距离，默认是1，为加快算法速度，可以调大（即：间隔选取‘块’）
    K2=32*n; % atom的个数。字典D的列数。一般取n的4倍，8倍。Number of dictionary atoms (e.g., K2=n)
    N=200*K2; % N: Number of signals used for training (e.g., N=200*K2)
    op=0; % If set to 1, K-SVD learning is done with fixed sparsity. For any other setting, K-SVD learning is done
             %  employing both sparsity level and an error threshold (faster). (e.g., op=1)
    th=2.5*(10^(-5)); %2.5*(10^(-5)); ; %3*(10^(-8));  % 阈值 一般1以下，看噪声情况。Threshold used in sparse representation of patches after training. To use threshold during training, set 
                     % op appropriately. (e.g., th=0.023)
    T0=5; % 稀疏度5-10。round((0.15)*n); Sparsity settings of patch (e.g., T0=round((0.15)*n) )
            
%DLMRI Parameters initialization
%T0=DLMRIparams.T0; %sparsity levels
%numiterKSVD=DLMRIparams.numiterateKSVD; %number of K-SVD iterations

%other parameters of K-SVD algorithm
param.errorFlag=0;
param.L=T0; %
param.K=K2;
param.numIteration=1; % number of K-SVD iterations
param.preserveDCAtom=0;
param.InitializationMethod='GivenMatrix'; param.displayProgress=0;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% fid = fopen('C:\ZXY\2D_ART+DL_antNo33-512x512_150Views-1step_1121\data\atn_512x512x251_No33.bin','rb'); % 读取真实图像
% RealImge=fread(fid,[param.nx,param.ny],'float32');
% kappa=5e3;%设定一个归一化参数 
% RealImge1= RealImge/kappa;%归一化   表示归一化后的投影数据
% fclose(fid);
fid = fopen('no_leg_atn_1.bin'); %读入图像数据
x = fread(fid,inf,'float');
x=reshape(x,[512,512,100]);
fclose(fid);
RealImge=x(:,:,65)*600;

smat=zeros(param.nx,param.ny);
RMSE=zeros(1,iter);
 for i=1:iter  %% do iterations
      fprintf(1,'the number of interation is %d\n',i);
    g=G'*(G*I-y);
    Gg=(G*g);
    tau=sum(g(:).^2)/sum(Gg(:).^2);
    I_f=I(:,[2:nx nx])-I;
    I_b=I-I(:,[1 1:nx-1]);
    I_u=I-I([1 1:ny-1],:);
    I_d=I([2:ny ny],:)-I;
    I_x_1=I(:,[2:nx nx])-I([1 1:ny-1],[2:nx nx]);
    I_y_1=I([2:ny ny],:)-I([2:ny ny],[1 1:ny-1]);
    den1=(a+I_b.^2+I_u.^2).^(0.5);
    den2=(a+I_f.^2+I_x_1.^2).^(0.5);
    den3=(a+I_d.^2+I_y_1.^2).^(0.5);

  if ~exist('P')
    v=(I_b+I_u)./den1-I_f./den2-I_d./den3;
    norm=(sum(sum(v.^2))).^(0.5);
    v=v./norm;
    u=tau*g+beta*dt*v;
    I=I-u;
  else
    Q=I-P;
    Q_f=Q(:,[2:nx nx])-Q;
    Q_b=Q-Q(:,[1 1:nx-1]);
    Q_u=Q-Q([1 1:ny-1],:);
    Q_d=Q([2:ny ny],:)-Q;
    Q_x_1=Q(:,[2:nx nx])-Q([1 1:ny-1],[2:nx nx]);
    Q_y_1=Q([2:ny ny],:)-Q([2:ny ny],[1 1:ny-1]);
    den4=(a+Q_b.^2+Q_u.^2).^(0.5);
    den5=(a+Q_f.^2+Q_x_1.^2).^(0.5);
    den6=(a+Q_d.^2+Q_y_1.^2).^(0.5);
    v1=(I_b+I_u)./den1-I_f./den2-I_d./den3;
    v2=(Q_b+Q_u)./den4-Q_f./den5-Q_d./den6;
    v=alpha*(v2)+(1-alpha)*(v1);
    norm=(sum(sum(v.^2))).^(0.5);
    v=v./norm;
    u=tau*g+beta*dt*v;
    I=I-u;
  
  end
    if mod(i,1)==0 %每隔n次进行DL操作///////////////////////////////////////////////
          I11=I;
          I=DLstep(I11,param,num,n,r,N,op,th,K2);
     end
    str1='E:\ZXY\bags\pwls no\data\PWLS-512x512-'; % 写入重建图像&&&&&&&&&&&&&
    str2='.dat';
    filename=[str1,num2str(i),str2];
%         if mod(i,5)==0 || i==1
            fid=fopen(filename,'wb');
            fwrite(fid,I,'float32');
            fclose(fid);
%         end   
       tmp=(RealImge-I).^2;
       RMSE(i)=sqrt(sum(tmp(:))/(512*512));  
       fprintf(1,'RMSE=%f,\n',RMSE(i));
  end 
         figure(1);
      x=1:iter;
      y=RMSE(x);
      save ('E:\ZXY\bags\pwls no\data\RMSE-500.mat','RMSE');
      plot(x,y);
      xlabel('迭代次数');
      ylabel('RMSE')
J=I;
